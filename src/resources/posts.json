[{"id":3,"title":"Longest Common Subsequence Algorithm","category":"Algorithm","language":"cpp","author":"Anis Sarker","content":"\n### Longest common subsequence\n\nThe longest common subsequence problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from the longest common substring problem: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.\n\nFor more: [Wiki](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)\n","codes":"#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nclass LCS\n{\n  private:\n  \tstring x, y;\n    int m, n;\n    int **C;\n\n\t\tvoid lcs_length()\n\t\t{\n\t\t\tfor(int i = 0; i <= m; ++i) C[i][0] = 0;\n\t\t\tfor(int j = 0; j <= n; ++j) C[0][j] = 0;\n\t\t\tfor(int i = 1; i <= m; ++i){\n\t\t\t\tfor(int j = 1; j <= n; ++j){\n\t\t\t\t\tif(x[i-1] == y[j-1]){\n\t\t\t\t\t\tC[i][j] = C[i-1][j-1] + 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(C[i][j-1] > C[i-1][j]){\n\t\t\t\t\t\t\tC[i][j] = C[i][j-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tC[i][j] = C[i-1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid recursive_lcs(int i, int j)\n\t\t{\n\t\t\tif(i == 0 || j == 0) return;\n\t\t\tif(C[i][j] == C[i-1][j]) return recursive_lcs(i-1, j);\n\t\t\telse if(C[i][j] == C[i][j-1]) return recursive_lcs(i, j-1);\n\t\t\telse{\n\t\t\t\trecursive_lcs(i-1, j-1);\n\t\t\t\t//cout << y[j-1];\n\t\t\t\tcout << x[i-1];\n\t\t\t}\n\t\t}\n\n\tpublic:\n\t\tLCS(string a, string b)\n\t\t{\n\t\t\tm = a.length();\n\t\t\tn = b.length();\n\t\t\tx = a;\n\t\t\ty = b;\n\n\t\t\tC = new int *[m + 1];\n\t\t\tfor(int i = 0; i <= m; ++i){\n\t\t\t\tC[i] = new int[n+1];\n\t\t\t}\n\t\t\tlcs_length();\n\t\t}\n\n\t\tint get_length()\n\t\t{\n\t\t\treturn C[m][n];\n\t\t}\n\n\t\tvoid get_lcs_string()\n\t\t{\n\t\t\trecursive_lcs(m, n);\n\t\t}\n\n\t\tvoid display_lcs_array()\n\t\t{\n\t\t\tint k;\n\t\t\tcout << endl;\n\t\t\tfor(int i = 0; i <= m; ++i){\n\t\t\t\tif(i != 0) cout << x[i-1] << \"  \";\n\t\t\t\tfor(int j = 0; j <= n; ++j){\n\t\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\t\tcout << \"   Yi   \";\n\t\t\t\t\t\tfor(k = 0; k < n; ++k)\n\t\t\t\t\t\t\tcout << y[k] << \"   \";\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\tcout << \"Xi \";\n\t\t\t\t\t}\n\t\t\t\t\tif(x[i-1] == y[j-1]){\n\t\t\t\t\t\tcout << \"(\"<< C[i][j] << \") \";\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout << \" \" << C[i][j] << \"  \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\n};\n\nint main()\n{\n\tstring a, b;\n\n\tcout << \"Enter 1st String: \";\n\tgetline(cin, a);\n\tcout << \"Enter 2nd String: \";\n\tgetline(cin, b);\n\n\tLCS lcs(a, b);\n\n\tcout << \"\\nLength of the Longest Common Subsequence: \" << lcs.get_length();\n\tcout << endl;\n\n\tcout << \"\\nLongest Common Subsequence of ( \" << a << \" ) & ( \" << b << \" ) : \";\n\tlcs.get_lcs_string();\n\tcout << endl;\n\n\tcout << \"\\nLCS Table : \" << endl;\n\tlcs.display_lcs_array();\n\n\treturn 0;\n}\n"},{"id":4,"title":"Histogram of an Image::Python","category":"Python","language":"python","author":"Anis Sarker","content":"\n### Image histogram of a gray image using python\n\n> This python function takes a 2d gray image as input and return the histogram of input image\n\n**Input:** *2D image*\\\n**Output:** *Histogram of the image*\n","codes":"import numpy as np\n\ndef histogram(img):\n\theight = img.shape[0]\n\twidth = img.shape[1]\n\t\n\thist = np.zeros((256))\n\n\tfor i in np.arange(height):\n\t\tfor j in np.arange(width):\n\t\t\ta = img.item(i,j)\n\t\t\thist[a] += 1\n\t\t\t\t\t\n\treturn hist\n"},{"id":2,"title":"Insertion Sort Algorithm","category":"Algorithm","language":"cpp,","author":"Anis Sarker","content":"\n### Insertion sort algorithm\n\nInsertion sort is a simple sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.\n\nFor more: [Wiki](https://en.wikipedia.org/wiki/Insertion_sort)\n","codes":"#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <unistd.h>\nusing namespace std;\n\nvoid generateArray();\nvoid printArray();\nvoid insertionSortDescending();\nvoid insertionSortAscending();\nvoid mergeSort();\n\n\nvoid generateArray(int *A, int n) {\n  for (int i=0; i<n; i++) {\n    A[i] = rand() % 50;\n  }\n}\n\nvoid printArray(int *A, int n) {\n  for (int i=0; i<n; i++) {\n    cout << A[i] << \"  \";\n  }\n}\n\nvoid insertionSortDescending(int *A, int n) {\n  int i, j, key;\n  for (i=1; i<n; i++) {\n    key = A[i];\n    j = i - 1;\n    while (j>=0 && A[j]<key) {\n      A[j+1] = A[j];\n      j--;\n    }\n    A[j+1] = key;\n  }\n}\n\nvoid insertionSortAscending(int *A, int n) {\n  int i, j, key;\n  for (i=1; i<n; i++) {\n    key = A[i];\n    j = i - 1;\n    while (j>=0 && A[j]>key) {\n      A[j+1] = A[j];\n      j--;\n    }\n    A[j+1] = key;\n  }\n}\n\nint main() {\n  int n;\n  int A[n];\n\n  cout << \"Generate Array\" << endl;\n  generateArray(A, 50);\n  printArray(A,20);\n\n  cout << \"\\nInsertion Sort Descending\" << endl;\n  insertionSortDescending(A, 50);\n  printArray(A, 50);\n\n  cout << \"\\nInsertion Sort Ascending\" << endl;\n  insertionSortAscending(A, 50);\n  printArray(A, 50);\n\n  return 0;\n}\n"},{"id":5,"title":"Some Quote","category":"Random","language":"unknown","author":"Anis Sarker","content":"\n### Some quote that I cherish...\n___\n\n> 'People seldom do what they believe in. They do what is convenient, then repent.' - Bob Dylan\n\n> There will be a time would come when you can't share your moments with everyone equally. For that, chaos within loved one is must avoidable.\n\n> No one likes hearing people say negative things about what they like\n\n> We care about color even though color does not exist\n\n> Everything in life follows a pattern...\n\n> I'm free but not available\n\n\\- Lol","codes":""},{"id":1,"title":"Merge Sort Algorithm","category":"Algorithm","language":"cpp","author":"Anis Sarker","content":"\n### Merge sort algorithm\n\nIn computer science, merge sort is an efficient, general-purpose, comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the order of equal elements is the same in the input and output. Merge sort is a divide and conquer algorithm that was invented by John von Neumann in 1945.\n\nFor more: [Wiki](https://en.wikipedia.org/wiki/Merge_sort)\n","codes":"#include <iostream>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\nclass Sort{\n  public:\n    void populate(int A[],int n)\n    {\n      int i;\n      srand(time(0));\n      for(i=0;i<n;i++)\n      A[i]=rand();\n    }\n\n    void display(int A[],int n)\n    {\n      int i;\n      for(i=0;i<n;i++)\n        cout<<A[i]<<\" \";\n    }\n\n    void Merge(int A[], int f, int m, int l)\n    {\n      int T[200000];\n      int i,j,k;\n      i=k=f;\n      j=m+1;\n\n      while(i<=m&&j<=l)\n      {\n        if(A[i]<=A[j]) T[k++]=A[i++];\n        else T[k++]=A[j++];\n      }\n      if(i==m+1){\n        while(j<=l) T[k++]=A[j++];\n      }else{\n        while(i<=m) T[k++]=A[i++];\n      }\n      for(i=f;i<=l;i++)\n      {\n        A[i]=T[i];\n      }\n    }\n    void mergeSort(int A[], int f, int l)\n    {\n      int m;\n      if(f<l){\n        m=(f+l)/2;\n        mergeSort(A,f,m);\n        mergeSort(A,m+1,l);\n        Merge(A,f,m,l);\n      }\n    }\n};\n\nint main(){\n  int n=200000;\n  int A[200000];\n  Sort obj;\n  obj.populate(A,n);\n  obj.mergeSort(A,0,n-1);\n  //obj.display(A,n);\n  \n  return 0;\n}\n"},{"id":6,"title":"String ABC","category":"Python","language":"python","author":"Anis Sarker","content":"\n## String ABC\n___\n\n### **Problem**\nFor integer k, define the ABC string of level k as follows. The level 1 ABC character string is `\"ABC\"`.\n\nThe level k ABC character string is\\\n`\"A\" + (level k -1 ABC character) + \"B\" + (level k -1 ABC character) + \"C\"`\n\n### **For Example**\nThe level 2 ABC character string is\\\n`\"A\" + \"ABC\" + \"B\" + \"ABC\" + \"C\" = \"AABCBABCC\"`\n\nPlease find from s character to t character of ABC character string of level k.\n\n**Example**\\\nIn input example 1, it is necessary to output the third to sixth characters of the level 2 ABC character string. Since the ABC character string of level 2 is `\"AABCBABCC\"`, the third character to the sixth character are `\"BCBA\"`, It is necessary to output `\"BCBA\"`.\n\n**Input Value**\\\nInput is given in the following format `k s t`\n\n* An integer k representing the level of the ABC character string, an integer s representing the beginning of the output position, and an integer t representing the end of the output position are given in this order with a space delimited.\n\n* The input is one line and one line feed is inserted at the end.\n\n**Expected Output**\\\nPlease output from s character to t character of ABC character string of level k.\n\nAt the end of the line break, do not include extra characters, blank lines.\n\n### **Conditions**\n1. `1 ≦ k ≦ 50`\n2. `1 ≤ s ≤ t ≤ Length of ABC character string at level k`\n3. `1 ≦ t - s + 1 ≦ 100`\n\n\n**Input Example 1**\n\n`2 3 6`\n\n**Output Example 1**\n\n`BCBA`\n\n**Input Example 2**\n\n`10 123 139`\n\n**Output Example 2**\n\n`BAAABCBABCCBAABCB`\n\n___\n### Code: `abc_string.py`\n___\n\n\\\n**Input**\n\n`python abc_string.py 2 3 6`\n\n**Output**\n\n`BCBA`\n\n**Input**\n\n`python3 abc_string.py 10 123 139`\n\n**Output**\n\n`BAAABCBABCCBAABCB`\n","codes":"import sys\n\n\"\"\" \n    Function: abc_string(str_abc, k)\n    Params: takes two paramter \n            str_abc as string\n            k as integer\n    Recursively output the ABC character string of level k \n\"\"\"\n\ndef abc_string(str_abc, k):\n    if k == 1:\n        return str_abc\n    abc__ = str_abc[0] + abc_string(str_abc, k-1) + str_abc[1] + abc_string(str_abc, k-1) + str_abc[2]\n    return abc__\n\n\ndef abc_substr(str_abc, k, s, t):\n    string_abc = ''\n    output_string = ''\n    if k < 1 or k > 50:\n        print('Error: k range must between 1 to 50')\n    else:\n        string_abc = abc_string(str_abc=str_abc, k=k)\n\n    if s > len(string_abc) and t > len(str_abc):\n        print('Error: s or t must not exceeds length of abc character string')\n    elif s < 1 or s > t:\n        print('Error: s range must between 1 to t')\n    elif t < 1 or (t-s+1) > 100:\n        print('Error: t range must between 1 to 100')\n    else:\n        output_string = string_abc[s-1:t]\n\n    return output_string\n    \n\nif __name__ == \"__main__\":\n\n    _ABC = 'ABC'\n\n    k = int(sys.argv[1])\n    s = int(sys.argv[2])\n    t = int(sys.argv[3])\n\n    print(abc_substr(str_abc=_ABC, k=k, s=s, t=t))    \n"}]